__author__ = 'Jake'

# This script processes raw data that is generated by running solver trials.
# A table of averaged data is generated and outputted to 'all_processed_data.txt'
#
# To accomplish this, follow this procedure:
# For a given glob pattern, load all files that match the pattern.
#   (a glob pattern is similar to a path name except it takes special '*', '?', and '[]'
#   symbols. This allows matching multiple files, for example "trials/*_raw_data.txt".)
# For each file loaded in this way, do the following:
# Extract the m value (contained in the filename, ie 'gen_n9_m{M_VALUE}_1000_raw_data.txt').
# Average all data contained in the file.
# Add the m value and averaged data as an entry into a growing list of overall collected data.
#   An entry should look something like this:
#       [m_value, avg_total_time, avg_init_time, avg_search_time,
#       avg_assignments, avg_solution_freq, avg_timeout_freq]
# Once finished, output a text file containing all the processed entries in a table format.

import sys
import os
import glob
import re
from src import rw


def isfloat(s):
    try:
        float(s)
        return True
    except:
        return False


def convert(s):
    """Converts a given string to either a float, True|False, or returns the original string."""
    if isfloat(s):
        return float(s)
    elif s == 'True':
        return True
    elif s == 'False':
        return False
    else:
        return s


def process(file):
    print 'Processing: ' + file
    m_value = re.search('_m\d*', file).group()[2:]

    file_data = [entry.split() for entry in rw.read_file(file).splitlines()]

    # averages[0] - time_overall_start
    # averages[1] - time_search_start
    # averages[2] - time_end
    # averages[3] - assignments
    # averages[4] - solution
    # averages[5] - timeout
    averages = [sum(col) / float(len(col)) for col in
                [[convert(s) for s in category[1:]] for category in zip(*file_data)]]

    avg_total_time = format(averages[2] - averages[0], '.2f')
    avg_init_time = format(averages[1] - averages[0], '.2f')
    avg_search_time = format(averages[2] - averages[1], '.2f')
    avg_assignments = format(averages[3], '.2f')
    avg_solution_freq = format(averages[4], '.3f')
    avg_timeout_freq = format(averages[5], '.3f')

    return [m_value, avg_total_time, avg_init_time, avg_search_time,
             avg_assignments, avg_solution_freq, avg_timeout_freq]


def adjust_col_widths(table):
    """Takes a 2 dimensional list of strings and adjusts the width of each column.
    The ith column is defined as including the ith element of each list in the table.
    Adjusting the width is accomplished by left justifying each element by the width of
    the longest element in that column.
    This way all columns will line up nicely when written to a text file.
    """
    zipped_table = zip(*table)
    col_widths = [max([len(item) for item in col]) for col in zipped_table]
    width_adjusted_columns = [[item.ljust(width) for item in column] for (width, column) in
                           zip(col_widths, zipped_table)]
    return zip(*width_adjusted_columns)


def main(argv):
    glob_pattern = argv[1]
    files = glob.glob(glob_pattern)
    directory = os.path.split(os.path.commonprefix(files))[0]  # The lowest common directory

    processed_data = [['m_value', 'total_time', 'init_time', 'search_time',
                      'assignments', 'solution_freq', 'timeout_freq']]

    for file in files:
        entry = process(file)
        processed_data.append(entry)

    processed_data = adjust_col_widths(processed_data)

    output_filename = directory + r'\all_processed_data.txt'
    output_str = '\n'.join('\t'.join(entry) for entry in processed_data)
    rw.write_file(output_filename, output_str, rw.OVERWRITE)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print "process_results.py requires exactly one parameter ({} given).".format(len(sys.argv) - 1)
        exit(-1)

    main(sys.argv)